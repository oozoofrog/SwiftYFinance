// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: PricingData.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct PricingData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var price: Float {
    get {return _storage._price}
    set {_uniqueStorage()._price = newValue}
  }

  var time: Int64 {
    get {return _storage._time}
    set {_uniqueStorage()._time = newValue}
  }

  var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  var exchange: String {
    get {return _storage._exchange}
    set {_uniqueStorage()._exchange = newValue}
  }

  var quoteType: Int32 {
    get {return _storage._quoteType}
    set {_uniqueStorage()._quoteType = newValue}
  }

  var marketHours: Int32 {
    get {return _storage._marketHours}
    set {_uniqueStorage()._marketHours = newValue}
  }

  var changePercent: Float {
    get {return _storage._changePercent}
    set {_uniqueStorage()._changePercent = newValue}
  }

  var dayVolume: Int64 {
    get {return _storage._dayVolume}
    set {_uniqueStorage()._dayVolume = newValue}
  }

  var dayHigh: Float {
    get {return _storage._dayHigh}
    set {_uniqueStorage()._dayHigh = newValue}
  }

  var dayLow: Float {
    get {return _storage._dayLow}
    set {_uniqueStorage()._dayLow = newValue}
  }

  var change: Float {
    get {return _storage._change}
    set {_uniqueStorage()._change = newValue}
  }

  var shortName: String {
    get {return _storage._shortName}
    set {_uniqueStorage()._shortName = newValue}
  }

  var expireDate: Int64 {
    get {return _storage._expireDate}
    set {_uniqueStorage()._expireDate = newValue}
  }

  var openPrice: Float {
    get {return _storage._openPrice}
    set {_uniqueStorage()._openPrice = newValue}
  }

  var previousClose: Float {
    get {return _storage._previousClose}
    set {_uniqueStorage()._previousClose = newValue}
  }

  var strikePrice: Float {
    get {return _storage._strikePrice}
    set {_uniqueStorage()._strikePrice = newValue}
  }

  var underlyingSymbol: String {
    get {return _storage._underlyingSymbol}
    set {_uniqueStorage()._underlyingSymbol = newValue}
  }

  var openInterest: Int64 {
    get {return _storage._openInterest}
    set {_uniqueStorage()._openInterest = newValue}
  }

  var optionsType: Int64 {
    get {return _storage._optionsType}
    set {_uniqueStorage()._optionsType = newValue}
  }

  var miniOption: Int64 {
    get {return _storage._miniOption}
    set {_uniqueStorage()._miniOption = newValue}
  }

  var lastSize: Int64 {
    get {return _storage._lastSize}
    set {_uniqueStorage()._lastSize = newValue}
  }

  var bid: Float {
    get {return _storage._bid}
    set {_uniqueStorage()._bid = newValue}
  }

  var bidSize: Int64 {
    get {return _storage._bidSize}
    set {_uniqueStorage()._bidSize = newValue}
  }

  var ask: Float {
    get {return _storage._ask}
    set {_uniqueStorage()._ask = newValue}
  }

  var askSize: Int64 {
    get {return _storage._askSize}
    set {_uniqueStorage()._askSize = newValue}
  }

  var priceHint: Int64 {
    get {return _storage._priceHint}
    set {_uniqueStorage()._priceHint = newValue}
  }

  var vol24Hr: Int64 {
    get {return _storage._vol24Hr}
    set {_uniqueStorage()._vol24Hr = newValue}
  }

  var volAllCurrencies: Int64 {
    get {return _storage._volAllCurrencies}
    set {_uniqueStorage()._volAllCurrencies = newValue}
  }

  var fromCurrency: String {
    get {return _storage._fromCurrency}
    set {_uniqueStorage()._fromCurrency = newValue}
  }

  var lastMarket: String {
    get {return _storage._lastMarket}
    set {_uniqueStorage()._lastMarket = newValue}
  }

  var circulatingSupply: Double {
    get {return _storage._circulatingSupply}
    set {_uniqueStorage()._circulatingSupply = newValue}
  }

  var marketCap: Double {
    get {return _storage._marketCap}
    set {_uniqueStorage()._marketCap = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension PricingData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PricingData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "price"),
    3: .same(proto: "time"),
    4: .same(proto: "currency"),
    5: .same(proto: "exchange"),
    6: .standard(proto: "quote_type"),
    7: .standard(proto: "market_hours"),
    8: .standard(proto: "change_percent"),
    9: .standard(proto: "day_volume"),
    10: .standard(proto: "day_high"),
    11: .standard(proto: "day_low"),
    12: .same(proto: "change"),
    13: .standard(proto: "short_name"),
    14: .standard(proto: "expire_date"),
    15: .standard(proto: "open_price"),
    16: .standard(proto: "previous_close"),
    17: .standard(proto: "strike_price"),
    18: .standard(proto: "underlying_symbol"),
    19: .standard(proto: "open_interest"),
    20: .standard(proto: "options_type"),
    21: .standard(proto: "mini_option"),
    22: .standard(proto: "last_size"),
    23: .same(proto: "bid"),
    24: .standard(proto: "bid_size"),
    25: .same(proto: "ask"),
    26: .standard(proto: "ask_size"),
    27: .standard(proto: "price_hint"),
    28: .standard(proto: "vol_24hr"),
    29: .standard(proto: "vol_all_currencies"),
    30: .standard(proto: "from_currency"),
    31: .standard(proto: "last_market"),
    32: .standard(proto: "circulating_supply"),
    33: .standard(proto: "market_cap"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _price: Float = 0
    var _time: Int64 = 0
    var _currency: String = String()
    var _exchange: String = String()
    var _quoteType: Int32 = 0
    var _marketHours: Int32 = 0
    var _changePercent: Float = 0
    var _dayVolume: Int64 = 0
    var _dayHigh: Float = 0
    var _dayLow: Float = 0
    var _change: Float = 0
    var _shortName: String = String()
    var _expireDate: Int64 = 0
    var _openPrice: Float = 0
    var _previousClose: Float = 0
    var _strikePrice: Float = 0
    var _underlyingSymbol: String = String()
    var _openInterest: Int64 = 0
    var _optionsType: Int64 = 0
    var _miniOption: Int64 = 0
    var _lastSize: Int64 = 0
    var _bid: Float = 0
    var _bidSize: Int64 = 0
    var _ask: Float = 0
    var _askSize: Int64 = 0
    var _priceHint: Int64 = 0
    var _vol24Hr: Int64 = 0
    var _volAllCurrencies: Int64 = 0
    var _fromCurrency: String = String()
    var _lastMarket: String = String()
    var _circulatingSupply: Double = 0
    var _marketCap: Double = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _price = source._price
      _time = source._time
      _currency = source._currency
      _exchange = source._exchange
      _quoteType = source._quoteType
      _marketHours = source._marketHours
      _changePercent = source._changePercent
      _dayVolume = source._dayVolume
      _dayHigh = source._dayHigh
      _dayLow = source._dayLow
      _change = source._change
      _shortName = source._shortName
      _expireDate = source._expireDate
      _openPrice = source._openPrice
      _previousClose = source._previousClose
      _strikePrice = source._strikePrice
      _underlyingSymbol = source._underlyingSymbol
      _openInterest = source._openInterest
      _optionsType = source._optionsType
      _miniOption = source._miniOption
      _lastSize = source._lastSize
      _bid = source._bid
      _bidSize = source._bidSize
      _ask = source._ask
      _askSize = source._askSize
      _priceHint = source._priceHint
      _vol24Hr = source._vol24Hr
      _volAllCurrencies = source._volAllCurrencies
      _fromCurrency = source._fromCurrency
      _lastMarket = source._lastMarket
      _circulatingSupply = source._circulatingSupply
      _marketCap = source._marketCap
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularFloatField(value: &_storage._price) }()
        case 3: try { try decoder.decodeSingularSInt64Field(value: &_storage._time) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._exchange) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._quoteType) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._marketHours) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._changePercent) }()
        case 9: try { try decoder.decodeSingularSInt64Field(value: &_storage._dayVolume) }()
        case 10: try { try decoder.decodeSingularFloatField(value: &_storage._dayHigh) }()
        case 11: try { try decoder.decodeSingularFloatField(value: &_storage._dayLow) }()
        case 12: try { try decoder.decodeSingularFloatField(value: &_storage._change) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._shortName) }()
        case 14: try { try decoder.decodeSingularSInt64Field(value: &_storage._expireDate) }()
        case 15: try { try decoder.decodeSingularFloatField(value: &_storage._openPrice) }()
        case 16: try { try decoder.decodeSingularFloatField(value: &_storage._previousClose) }()
        case 17: try { try decoder.decodeSingularFloatField(value: &_storage._strikePrice) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._underlyingSymbol) }()
        case 19: try { try decoder.decodeSingularSInt64Field(value: &_storage._openInterest) }()
        case 20: try { try decoder.decodeSingularSInt64Field(value: &_storage._optionsType) }()
        case 21: try { try decoder.decodeSingularSInt64Field(value: &_storage._miniOption) }()
        case 22: try { try decoder.decodeSingularSInt64Field(value: &_storage._lastSize) }()
        case 23: try { try decoder.decodeSingularFloatField(value: &_storage._bid) }()
        case 24: try { try decoder.decodeSingularSInt64Field(value: &_storage._bidSize) }()
        case 25: try { try decoder.decodeSingularFloatField(value: &_storage._ask) }()
        case 26: try { try decoder.decodeSingularSInt64Field(value: &_storage._askSize) }()
        case 27: try { try decoder.decodeSingularSInt64Field(value: &_storage._priceHint) }()
        case 28: try { try decoder.decodeSingularSInt64Field(value: &_storage._vol24Hr) }()
        case 29: try { try decoder.decodeSingularSInt64Field(value: &_storage._volAllCurrencies) }()
        case 30: try { try decoder.decodeSingularStringField(value: &_storage._fromCurrency) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._lastMarket) }()
        case 32: try { try decoder.decodeSingularDoubleField(value: &_storage._circulatingSupply) }()
        case 33: try { try decoder.decodeSingularDoubleField(value: &_storage._marketCap) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if _storage._price.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._price, fieldNumber: 2)
      }
      if _storage._time != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._time, fieldNumber: 3)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 4)
      }
      if !_storage._exchange.isEmpty {
        try visitor.visitSingularStringField(value: _storage._exchange, fieldNumber: 5)
      }
      if _storage._quoteType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._quoteType, fieldNumber: 6)
      }
      if _storage._marketHours != 0 {
        try visitor.visitSingularInt32Field(value: _storage._marketHours, fieldNumber: 7)
      }
      if _storage._changePercent.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._changePercent, fieldNumber: 8)
      }
      if _storage._dayVolume != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._dayVolume, fieldNumber: 9)
      }
      if _storage._dayHigh.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._dayHigh, fieldNumber: 10)
      }
      if _storage._dayLow.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._dayLow, fieldNumber: 11)
      }
      if _storage._change.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._change, fieldNumber: 12)
      }
      if !_storage._shortName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._shortName, fieldNumber: 13)
      }
      if _storage._expireDate != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._expireDate, fieldNumber: 14)
      }
      if _storage._openPrice.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._openPrice, fieldNumber: 15)
      }
      if _storage._previousClose.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._previousClose, fieldNumber: 16)
      }
      if _storage._strikePrice.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._strikePrice, fieldNumber: 17)
      }
      if !_storage._underlyingSymbol.isEmpty {
        try visitor.visitSingularStringField(value: _storage._underlyingSymbol, fieldNumber: 18)
      }
      if _storage._openInterest != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._openInterest, fieldNumber: 19)
      }
      if _storage._optionsType != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._optionsType, fieldNumber: 20)
      }
      if _storage._miniOption != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._miniOption, fieldNumber: 21)
      }
      if _storage._lastSize != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._lastSize, fieldNumber: 22)
      }
      if _storage._bid.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._bid, fieldNumber: 23)
      }
      if _storage._bidSize != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._bidSize, fieldNumber: 24)
      }
      if _storage._ask.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._ask, fieldNumber: 25)
      }
      if _storage._askSize != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._askSize, fieldNumber: 26)
      }
      if _storage._priceHint != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._priceHint, fieldNumber: 27)
      }
      if _storage._vol24Hr != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._vol24Hr, fieldNumber: 28)
      }
      if _storage._volAllCurrencies != 0 {
        try visitor.visitSingularSInt64Field(value: _storage._volAllCurrencies, fieldNumber: 29)
      }
      if !_storage._fromCurrency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fromCurrency, fieldNumber: 30)
      }
      if !_storage._lastMarket.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastMarket, fieldNumber: 31)
      }
      if _storage._circulatingSupply.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._circulatingSupply, fieldNumber: 32)
      }
      if _storage._marketCap.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._marketCap, fieldNumber: 33)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PricingData, rhs: PricingData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._exchange != rhs_storage._exchange {return false}
        if _storage._quoteType != rhs_storage._quoteType {return false}
        if _storage._marketHours != rhs_storage._marketHours {return false}
        if _storage._changePercent != rhs_storage._changePercent {return false}
        if _storage._dayVolume != rhs_storage._dayVolume {return false}
        if _storage._dayHigh != rhs_storage._dayHigh {return false}
        if _storage._dayLow != rhs_storage._dayLow {return false}
        if _storage._change != rhs_storage._change {return false}
        if _storage._shortName != rhs_storage._shortName {return false}
        if _storage._expireDate != rhs_storage._expireDate {return false}
        if _storage._openPrice != rhs_storage._openPrice {return false}
        if _storage._previousClose != rhs_storage._previousClose {return false}
        if _storage._strikePrice != rhs_storage._strikePrice {return false}
        if _storage._underlyingSymbol != rhs_storage._underlyingSymbol {return false}
        if _storage._openInterest != rhs_storage._openInterest {return false}
        if _storage._optionsType != rhs_storage._optionsType {return false}
        if _storage._miniOption != rhs_storage._miniOption {return false}
        if _storage._lastSize != rhs_storage._lastSize {return false}
        if _storage._bid != rhs_storage._bid {return false}
        if _storage._bidSize != rhs_storage._bidSize {return false}
        if _storage._ask != rhs_storage._ask {return false}
        if _storage._askSize != rhs_storage._askSize {return false}
        if _storage._priceHint != rhs_storage._priceHint {return false}
        if _storage._vol24Hr != rhs_storage._vol24Hr {return false}
        if _storage._volAllCurrencies != rhs_storage._volAllCurrencies {return false}
        if _storage._fromCurrency != rhs_storage._fromCurrency {return false}
        if _storage._lastMarket != rhs_storage._lastMarket {return false}
        if _storage._circulatingSupply != rhs_storage._circulatingSupply {return false}
        if _storage._marketCap != rhs_storage._marketCap {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
